package config

import (
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestLoad_DefaultValues(t *testing.T) {
	// Clear all relevant environment variables
	clearEnv(t)

	cfg := Load()

	assert.Equal(t, "8080", cfg.Port)
	assert.Equal(t, "development", cfg.Environment)
	assert.Equal(t, []string{"http://localhost:5173"}, cfg.AllowedOrigins)
	assert.Equal(t, "http://localhost:5173", cfg.FrontendURL)
	assert.Empty(t, cfg.GoogleClientID)
	assert.Empty(t, cfg.GoogleSecret)
	assert.Empty(t, cfg.GoogleRedirectURL)
	assert.NotEmpty(t, cfg.JWTSecret) // Should be auto-generated
}

func TestLoad_CustomValues(t *testing.T) {
	// Clear all relevant environment variables first
	clearEnv(t)

	// Set custom environment variables
	setEnv(t, "PORT", "3000")
	setEnv(t, "GO_ENV", "production")
	setEnv(t, "ALLOWED_ORIGINS", "https://example.com,https://api.example.com")
	setEnv(t, "FRONTEND_URL", "https://example.com")
	setEnv(t, "GOOGLE_CLIENT_ID", "test-client-id")
	setEnv(t, "GOOGLE_CLIENT_SECRET", "test-secret")
	setEnv(t, "GOOGLE_REDIRECT_URL", "https://example.com/callback")
	setEnv(t, "JWT_SECRET", "test-jwt-secret")

	cfg := Load()

	assert.Equal(t, "3000", cfg.Port)
	assert.Equal(t, "production", cfg.Environment)
	assert.Equal(t, []string{"https://example.com", "https://api.example.com"}, cfg.AllowedOrigins)
	assert.Equal(t, "https://example.com", cfg.FrontendURL)
	assert.Equal(t, "test-client-id", cfg.GoogleClientID)
	assert.Equal(t, "test-secret", cfg.GoogleSecret)
	assert.Equal(t, "https://example.com/callback", cfg.GoogleRedirectURL)
	assert.Equal(t, "test-jwt-secret", cfg.JWTSecret)
}

func TestLoad_AllowedOrigins_CommaSeparated(t *testing.T) {
	clearEnv(t)

	tests := []struct {
		name     string
		envValue string
		expected []string
	}{
		{
			name:     "single origin",
			envValue: "https://example.com",
			expected: []string{"https://example.com"},
		},
		{
			name:     "multiple origins",
			envValue: "https://example.com,https://api.example.com,https://app.example.com",
			expected: []string{"https://example.com", "https://api.example.com", "https://app.example.com"},
		},
		{
			name:     "origins with spaces",
			envValue: "https://example.com, https://api.example.com , https://app.example.com",
			expected: []string{"https://example.com", "https://api.example.com", "https://app.example.com"},
		},
		{
			name:     "wildcard origin",
			envValue: "*",
			expected: []string{"*"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			clearEnv(t)
			setEnv(t, "ALLOWED_ORIGINS", tt.envValue)

			cfg := Load()

			assert.Equal(t, tt.expected, cfg.AllowedOrigins)
		})
	}
}

func TestLoad_JWTSecret_AutoGenerated(t *testing.T) {
	clearEnv(t)
	// Ensure JWT_SECRET is not set
	_ = os.Unsetenv("JWT_SECRET")

	cfg := Load()

	// Auto-generated secret should not be empty
	assert.NotEmpty(t, cfg.JWTSecret)
	// Should be a valid base64 string or the fallback
	assert.True(t, len(cfg.JWTSecret) > 10)
}

func TestLoad_JWTSecret_FromEnv(t *testing.T) {
	clearEnv(t)
	expectedSecret := "my-custom-jwt-secret-key"
	setEnv(t, "JWT_SECRET", expectedSecret)

	cfg := Load()

	assert.Equal(t, expectedSecret, cfg.JWTSecret)
}

func TestIsProduction(t *testing.T) {
	tests := []struct {
		name        string
		environment string
		expected    bool
	}{
		{
			name:        "production environment",
			environment: "production",
			expected:    true,
		},
		{
			name:        "prod environment",
			environment: "prod",
			expected:    true,
		},
		{
			name:        "development environment",
			environment: "development",
			expected:    false,
		},
		{
			name:        "dev environment",
			environment: "dev",
			expected:    false,
		},
		{
			name:        "staging environment",
			environment: "staging",
			expected:    false,
		},
		{
			name:        "empty environment",
			environment: "",
			expected:    false,
		},
		{
			name:        "test environment",
			environment: "test",
			expected:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cfg := &Config{
				Environment: tt.environment,
			}

			result := cfg.IsProduction()

			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGenerateRandomSecret(t *testing.T) {
	secret1 := generateRandomSecret()
	secret2 := generateRandomSecret()

	// Secrets should not be empty
	assert.NotEmpty(t, secret1)
	assert.NotEmpty(t, secret2)

	// Each generated secret should be unique
	assert.NotEqual(t, secret1, secret2)

	// Should be reasonable length (32 bytes base64 encoded = 44 chars, or fallback = 43 chars)
	assert.True(t, len(secret1) >= 40)
}

func TestGetEnv(t *testing.T) {
	tests := []struct {
		name         string
		key          string
		defaultValue string
		envValue     string
		expected     string
	}{
		{
			name:         "env var set",
			key:          "TEST_VAR",
			defaultValue: "default",
			envValue:     "custom",
			expected:     "custom",
		},
		{
			name:         "env var not set",
			key:          "TEST_VAR_UNSET",
			defaultValue: "default",
			envValue:     "",
			expected:     "default",
		},
		{
			name:         "env var empty string",
			key:          "TEST_VAR_EMPTY",
			defaultValue: "default",
			envValue:     "",
			expected:     "default",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.envValue != "" {
				_ = os.Setenv(tt.key, tt.envValue)
				defer func() { _ = os.Unsetenv(tt.key) }()
			} else {
				_ = os.Unsetenv(tt.key)
			}

			result := getEnv(tt.key, tt.defaultValue)

			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestLoad_IntegrationScenario(t *testing.T) {
	// Simulate a production environment configuration
	clearEnv(t)
	setEnv(t, "PORT", "443")
	setEnv(t, "GO_ENV", "production")
	setEnv(t, "ALLOWED_ORIGINS", "https://app.example.com,https://www.example.com")
	setEnv(t, "FRONTEND_URL", "https://app.example.com")
	setEnv(t, "GOOGLE_CLIENT_ID", "123456789.apps.googleusercontent.com")
	setEnv(t, "GOOGLE_CLIENT_SECRET", "GOCSPX-secretkey")
	setEnv(t, "GOOGLE_REDIRECT_URL", "https://app.example.com/auth/callback")
	setEnv(t, "JWT_SECRET", "super-secret-jwt-key-for-production")

	cfg := Load()

	// Verify all settings
	assert.Equal(t, "443", cfg.Port)
	assert.True(t, cfg.IsProduction())
	assert.Len(t, cfg.AllowedOrigins, 2)
	assert.Contains(t, cfg.AllowedOrigins, "https://app.example.com")
	assert.Contains(t, cfg.AllowedOrigins, "https://www.example.com")
	assert.Equal(t, "https://app.example.com", cfg.FrontendURL)
	assert.Equal(t, "123456789.apps.googleusercontent.com", cfg.GoogleClientID)
	assert.Equal(t, "GOCSPX-secretkey", cfg.GoogleSecret)
	assert.Equal(t, "https://app.example.com/auth/callback", cfg.GoogleRedirectURL)
	assert.Equal(t, "super-secret-jwt-key-for-production", cfg.JWTSecret)
}

func TestAllowedOrigins_Trimming(t *testing.T) {
	clearEnv(t)
	// Set origins with various whitespace
	setEnv(t, "ALLOWED_ORIGINS", "  https://example1.com  ,  https://example2.com,https://example3.com  ")

	cfg := Load()

	// All origins should be trimmed
	assert.Equal(t, []string{"https://example1.com", "https://example2.com", "https://example3.com"}, cfg.AllowedOrigins)
	for _, origin := range cfg.AllowedOrigins {
		assert.Equal(t, strings.TrimSpace(origin), origin, "origin should be trimmed")
	}
}

// Helper functions

func clearEnv(t *testing.T) {
	t.Helper()
	_ = os.Unsetenv("PORT")
	_ = os.Unsetenv("GO_ENV")
	_ = os.Unsetenv("ALLOWED_ORIGINS")
	_ = os.Unsetenv("FRONTEND_URL")
	_ = os.Unsetenv("GOOGLE_CLIENT_ID")
	_ = os.Unsetenv("GOOGLE_CLIENT_SECRET")
	_ = os.Unsetenv("GOOGLE_REDIRECT_URL")
	_ = os.Unsetenv("JWT_SECRET")
}

func setEnv(t *testing.T, key, value string) {
	t.Helper()
	err := os.Setenv(key, value)
	require.NoError(t, err)
	t.Cleanup(func() {
		_ = os.Unsetenv(key)
	})
}
